#!/bin/bash

######--Backup Preparation--######

#Prompt to define wasabi access key
while true 
	do
		read -p "Please enter your Wasabi Access Key: `echo $'\n> '`" ACCESS_KEY
		read -p "You entered '$ACCESS_KEY' is this correct?(y/n)" yn
			case $yn in
			[Yy]* ) break;;
			[Nn]* ) echo "Please try again:";sleep 2s;;
				* ) echo "Please answer yes or no.";;
			esac
done

#Prompt to define wasabi secret key
while true 
	do
		read -p "Please enter your Wasabi Secret Key: `echo $'\n> '`" SECRET_KEY
		read -p "You entered '$SECRET_KEY' is this correct?(y/n)" yn
			case $yn in
			[Yy]* ) break;;
			[Nn]* ) echo "Please try again:";sleep 2s;;
                * ) echo "Please answer yes or no.";;
			esac
done

#Prompt to define bucket region
while true 
	do
		read -p "Please enter the region selected when creating the bucket [eu-central-1]: `echo $'\n> '`" BUCKET_LOC
		BUCKET_LOC=${BUCKET_LOC:-eu-central-1}                                                          #Used to provide default option
		read -p "You selected '$BUCKET_LOC' is this correct?(y/n)" yn
			case $yn in
			[Yy]* ) break;;
			[Nn]* ) echo "Please try again:";sleep 2s;;
                * ) echo "Please answer yes or no.";;
			esac
done
				
#Prompt to define bucket name
while true 
	do
		read -p "Please enter the name of the bucket you created: `echo $'\n> '`" BUCKET
		read -p "You entered '$BUCKET' is this correct?(y/n)" yn
			case $yn in
			[Yy]* ) break;;
			[Nn]* ) echo "Please try again:";sleep 2s;;
                * ) echo "Please answer yes or no.";;
			esac
done

#Prompt to define repo location
while true 
	do
		read -p "Please enter a location for the backup repository [/BACKUP]: `echo $'\n> '`" MNT
		MNT=${MNT:-/BACKUP}                                                          #Used to provide default option
		read -p "You selected '$MNT' is this correct?(y/n)" yn
			case $yn in
			[Yy]* ) break;;
			[Nn]* ) echo "Please try again:";sleep 2s;;
				* ) echo "Please answer yes or no.";;
			esac
done

mkdir $MNT 2>/dev/null >/dev/null
chmod 777 $MNT	
	
if [ "${MNT: -1}" == "/" ]  #Checks if there is a forward slash in the path and if there is removes it
	then 
		MNT=${MNT%?}
	fi				
				
echo "Installing S3FS and Fuse"
sleep 2s
apt install s3fs fuse -y 
echo $ACCESS_KEY:$SECRET_KEY > ~/.passwd-s3fs
chmod 600 ~/.passwd-s3fs
echo "Your keys were saved in ~/.passwd-s3fs"

#If unsure of what failed comment the first line and uncomment the second line to enable debug mode
echo "Mounting Wasabi Bucket"
s3fs $BUCKET $MNT -o passwd_file=${HOME}/.passwd-s3fs -o url=https://s3.$BUCKET_LOC.wasabisys.com
#s3fs $BUCKET $MNT -o passwd_file=${HOME}/.passwd-s3fs -o url=https://s3.$BUCKET_LOC.wasabisys.com -o dbglevel=info -f -o rldbg

echo "Verifying Mount"

mount -l | grep $MNT 

if [ $? -ne 0 ]

	# If success
	then
		echo "Mounting has failed. Please try doing it manually."
		printf "\n"
		sleep 3s
		exit 1 # Exit with general error

	# If failure
	else
		echo "Bucket mounted successfully."
		printf "\n"
		sleep 3s
	fi

#Option to mount bucket at boot
while true; 
	do
		read -p "Do you wish to mount the bucket at boot?(yn)" yn
			case $yn in
			[Yy]* ) echo "s3fs#$BUCKET $MNT fuse _netdev,allow_other,use_path_request_style,url=https://s3.$BUCKET_LOC.wasabisys.com/ 0 0" >> /etc/fstab;break;;
			[Nn]* ) break;;
				* ) echo "Please answer yes or no.";;
			esac
done

#Prompt to define repo name
while true 
	do
		read -p "Please enter a name for your backup repository: `echo $'\n> '`" REPO
		read -p "You entered '$REPO' is this correct?(y/n)" yn
			case $yn in
			[Yy]* ) break;;
			[Nn]* ) echo "Please try again:";sleep 2s;;
				* ) echo "Please answer yes or no.";;
			esac
done

#Prompt to define encryption key
read -s -p "Please enter the repository encryption key: `echo $'\n> '`" ENCRYPT1
read -s -p "Please confirm the encryption key: `echo $'\n> '`" ENCRYPT2

# check if keys match and if not ask again
while [ "$ENCRYPT1" != "$ENCRYPT2" ];
	do
		echo "Key Mismatch. Please try again."
		read -s -p "Please enter the repository encryption key: `echo $'\n> '`" ENCRYPT1
		read -s -p "Please confirm the encryption key: `echo $'\n> '`" ENCRYPT2
done

ENCRYPT=$ENCRYPT2

#Repo Creation
echo "Creating Repos"
echo "--------------"
  /usr/bin/expect <(cat << EOF
spawn borg init --encryption=repokey-blake2 $MNT/$REPO
expect "Enter new passphrase:"
send "$ENCRYPT\r"
expect "Enter same passphrase again:"
send "$ENCRYPT\r"
expect "Do you want your passphrase to be displayed for verification?*:"
send "n\r"
interact
EOF
)

echo "Checking to see if repo was created on your system."
printf "\n"
sleep 1s

 /usr/bin/expect <(cat << EOF
spawn borg info $MNT/$REPO 
expect "Enter passphrase for key $MNT/$REPO:"
send "$ENCRYPT\r"
interact
EOF
)

if [ $? -ne 0 ]

	# If success
	then
		echo "Repo creation failed please try creating it manually."
		printf "\n"
		sleep 3s
		exit 1 # Exit with general error

	# If failure
	else
		echo "Repo created successfully."
		printf "\n"
		sleep 3s
	fi

borg key export $MNT/$REPO $TEMP/$REPO_Key.txt
printf "\n"
echo "Your encryption key for this repo is:"
printf "\n"
printf "\n"
cat $TEMP/$REPO_Key.txt
printf "\n"
echo "Please save the key or the file with it located in $TEMP/$REPO_Key.txt"
read -p "Press enter to continue"

# Checking to see if the Mail package is installed on your system
# Used for sending email confirmations of the backup process
MUTT='mutt'     
echo "Checking to see if '$MUTT' is installed on your system."
printf "\n"
sleep 2s

dpkg -s $MUTT 2>/dev/null >/dev/null

if [ $? -ne 0 ]

	# If success
	then
		echo "The '$MUTT' package is not installed on your system."
		echo "Package '$MUTT' will now be installed."
		printf "\n"
		sleep 2s
		INSTALL=$
		set -x                               #Sends output to terminal
		(apt install $MUTT -y) 
		{ set +x; } 2>/dev/null              #Stops output to terminal and hides set+x from output

			if [ $? -eq 0 ]

				# If success
				then
					echo "The '$MUTT' package was installed successfully. You will receive email updates for this backup."
					echo "..."
					printf "\n"
					sleep 2s
				# If failure
				else
					echo "Install of '$MUTT' package failed."
					printf "\n"
					echo "Please try installing it manually."
					printf "\n"
					sleep 5s
					exit 1 # Exit with general error
				fi
	else
		echo "The '$MUTT' package is installed on your system. You will receive email updates for this backup."
		echo "..."
		printf "\n"
		sleep 2s
	fi

printf "\n"

#Prompt to define notification email
while true 
	do
		read -p "Please define email to receive backup notifications: `echo $'\n> '`" MAIL
		read -p "You entered '$MAIL' is this correct?(y/n)" yn
			case $yn in
			[Yy]* ) break;;
			[Nn]* ) echo "Please try again:";sleep 2s;;
				* ) echo "Please answer yes or no.";;
			esac
done

#Prompt to define sender email
while true 
	do
		read -p "Please define email sender for backup notifications.
This email has to be configured on your SMTP server:`echo $'\n> '`" FROM_MAIL
		read -p "You entered '$FROM_MAIL' is this correct?(y/n)" yn
			case $yn in
			[Yy]* ) break;;
			[Nn]* ) echo "Please try again:";sleep 2s;;
                * ) echo "Please answer yes or no.";;
			esac
done

#Prompt to define SMTP password
read -s -p "Please enter the SMTP password for your server: `echo $'\n> '`" SMTP_PASS1
read -s -p "Please confirm your SMTP password: `echo $'\n> '`" SMTP_PASS2

# check if passwords match and if not ask again
while [ "$SMTP_PASS1" != "$SMTP_PASS2" ];
	do
		echo "Password Mismatch. Please try again."
		read -s -p "Please enter the SMTP password for your server: `echo $'\n> '`" SMTP_PASS1
		read -s -p "Please confirm your SMTP password: `echo $'\n> '`" SMTP_PASS2
done

SMTP_PASS=$SMTP_PASS2

#Prompt to define sender name
while true 
	do
		read -p "Please define sender name for backup notifications: `echo $'\n> '`" FROM_NAME
		read -p "You entered '$FROM_NAME' is this correct?(y/n)" yn
			case $yn in
			[Yy]* ) break;;
			[Nn]* ) echo "Please try again:";sleep 2s;;
				* ) echo "Please answer yes or no.";;
			esac
done
                
#Prompt to define SMTP URL
while true 
	do
		read -p "Please indicate the URL to your SMTP server in the following format (mail.domain.com:587): `echo $'\n> '`" SMTP_URL
		read -p "You entered '$SMTP_URL' is this correct?(y/n)" yn
			case $yn in
			[Yy]* ) break;;
			[Nn]* ) echo "Please try again:";sleep 2s;;
				* ) echo "Please answer yes or no.";;
			esac
done
                
set -x                               #Sends output to terminal
(wget -P $TEMP https://raw.githubusercontent.com/The-Inamati/LXD-Backup-Script/master/Mutt_Config_File)
mv $TEMP/Mutt_Config_File ~/.muttrc
{ set +x; } 2>/dev/null              #Stops output to terminal and hides set+x from output
sed -i -e "s/\$FROM_MAIL/$FROM_MAIL/" -e "s/\$FROM_NAME/$FROM_NAME/" -e "s/\$SMTP_PASS/$SMTP_PASS/" -e "s/\$SMTP_URL/$SMTP_URL/"  ~/.muttrc   #Substitutes variables in downloaded configuration file


mkdir -p ~/.mutt/cache #Creates cache directory for Mutt

echo "Mutt was intalled and configured successfully." 
echo "Email notifications were configured with settings indicated in the attachment." | mutt  -s "Backup Test Email" $MAIL -a ~/.muttrc  #email notification
echo "A test email was just sent with the details you specified. Please confirm you received it.
In case you don't receive it please check your Mutt configuration at ~/.muttrc.
The email may also be greylisted. Please try again with the command shown below after the script finishes. 
<echo "Body Text" | mutt -s "Subject" email@mail.domain.com -a ~/.muttrc>"
read -p "Press enter to continue"
		
echo "Continuing with backup in 5 seconds."
echo "------------------------------------"
sleep 5s 


####--Backup--####

cd $LXD
for i in * 
	do
		NAME=$i
		# Check if the required arguments are not empty
		if [ "$i" == '' ];
			# If none of these arguments are empty, the script can proceed
			then
				echo "One or more arguments are empty."
				echo "A log file exists in $TEMP/backup_log_$BEGIN.txt"
				sleep 5s
				exit 1 # Exit with general error
			
			# If one or more arguments are empty, produce an error
			else
				# Clear terminal window
				clear

				# Welcome/Start message
				echo "****************************************"
				echo "LXD Container Backup Script"
				echo "Created for Peace of Mind"
				echo "****************************************"
				
				printf "\n"
				
				echo "Starting in 5 seconds."
				echo "..."
				printf "\n"
				sleep 5s # Wait 5 seconds
		
				echo "The snapshot backup filename will be: $FILENAME"
				echo "Stored temporarily within: $TEMP"
				echo "Full temporary savepath: $TEMP/$FILENAME"
				printf "\n"
				sleep 5s # Wait 5 seconds
		
		
				# Start snapshot backup process
				echo "Starting snapshot backup process..."
				echo "Please be patient, this can take a while"
		
				# Create a snapshot of the container, with the snapshot name being 'backup'
				echo "Creating 'backup' snapshot of '$NAME'."
				lxc snapshot $NAME backup
		
				# Publish this snapshot temporarily with an alias name of 'lxd-image-backup-$NAME'
				echo "Publishing 'backup' snapshot temporarily with an alias name of 'lxd-image-backup-$NAME'."
				lxc publish $NAME/backup --alias lxd-image-backup-$NAME
		
				# Export the 'lxd-image-backup-$NAME' image, this will save the export in a 'tar.gz' format to the specified temporary location
				echo "Exporting 'lxd-image-backup-$NAME' image in this location: '$TEMP/$FILENAME'."
				#lxc image export lxd-image-backup-$NAME .
				lxc image export lxd-image-backup-$NAME $TEMP/$FILENAME_NOFORMAT
			fi
done				
#Backup the Containers
set -x
borgmatic --verbosity 1
{ set +x; } 2>/dev/null              #Stops output to terminal and hides set+x from output      
      
cd $LXD
for i in * 
	do        
		NAME=$i
		# Now delete the 'lxd-image-backup-$NAME' image
		echo "Deleting 'lxd-image-backup-$NAME' image from server."
		lxc image delete lxd-image-backup-$NAME
	
		# And delete the temporary 'backup' snapshot
		echo "Deleting temporary 'backup' snapshot from server."
		lxc delete local:$NAME/backup
	
		echo "Snapshot backup process has finished."
		echo "..."
		printf "\n"
	
	
		# Verify snapshot file has been created
		echo "Verifying $FILENAME file has been created."
		printf "\n"

			if [ -f $TEMP/$FILENAME ]

				# If success
				then
					echo "File exists on the local server."
					printf "\n"
					
					# Remove snapshot file from the local server
					echo "Now removing $FILENAME from the local server."
					rm $TEMP/$FILENAME
					echo "Finished removing file."
					echo "..."
					printf "\n"
		
					# Verify snapshot file has been removed from the local server
					echo "Verifying $FILENAME has been removed from the local server."
					echo "..."
					printf "\n"

						if [ -f $TEMP/$FILENAME ]

							# If success
							then
								echo "File still exists on the local server."
								echo "Backup has failed."
								printf "\n"
			
								# Send an email explaining this failure
								echo "An email will be sent to $MAIL"
								echo "$FILENAME was supposed to be removed, but still exists on the local server."
								echo "Failed removing snapshot file from local server." | mutt  -s "Backup Failed" $MAIL
								echo "A log file exists in $TEMP/backup_log_$BEGIN.txt"
								sleep 5s
								exit 1 # Exit with general error

							# If failure
							else
								echo "Backup has finished successfully."
								printf "\n"
				
								# Send an email explaing a successful backup
								END=$(date +%Y-%m-%d-%H:%M)
								TOTAL=$(expr %END - $BEGIN)	
 /usr/bin/expect <(cat << EOF
spawn borg info $MNT/$REPO 
expect "Enter passphrase for key $MNT/$REPO:"
send "$ENCRYPT\r"
interact
EOF
) >> /tmp/backup.txt						
								echo "An email will be sent to $MAIL"
								echo "Backup has finished successfully. $FILENAME has been created and backed up successfully." 
								echo "Backup has finished successfully. $FILENAME has been created and backed up successfully.
								Total backup time was $TOTAL. Log and size of backup are in attachments" | mail -s "Success: $NAME Backup" $MAIL -a $TEMP/backup_log_$BEGIN.txt -a /tmp/backup.txt #adicionar total de tempo ao email
								rm /tmp/backup.txt
								echo "A log file exists in $TEMP/backup_log_$BEGIN.txt"
								printf "\n"
									while true; 
										do
											read -p "Do you wish to delete the log file?(y/n)" yn
												case $yn in
												[Yy]* ) rm $TEMP/backup_log_$BEGIN.txt;break;;
												[Nn]* ) break;;
													* ) echo "Please answer yes or no.";;
												esac
									done
							fi
                                                
     
				# If failure
				else
					echo "File does not exist on the local server."
					echo "Backup has failed."
					printf "\n"

					# Send an email explaining this failure
					echo "An email will be sent to $MAIL"
					echo "Creating $FILENAME on local server failed." 
					echo "Creating $FILENAME on local server failed." | mutt  -s "Backup Failed" $MAIL
					echo "A log file exists in $TEMP/backup_log_$BEGIN.txt"
					sleep 5s
					exit 1 # Exit with general error

				fi     
done

exit 0 # Successful exit
